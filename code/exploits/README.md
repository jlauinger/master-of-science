# Go unsafe.Pointer vulnerability POCs

This directory contains experimental and working proof of concept (POC) code listings to show some possible
vulnerabilities that can come from incorrect usage of unsafe in Go.


## Information leak POC

This proof of concept shows how casting buffers of differing lengths using `unsafe.Pointer` potentially leads
to a buffer overflow, resulting in an information leak in this POC.

A possible threat model to introduce this code pattern is a miscommunication within a software development team.

The exploit code along with instructions to execute it is located in the `information-leak/` directory.


## Code flow redirection POC

This proof of concept shows how an incorrect array cast can lead to a code flow redirection
vulnerability, executing a function built into the binary.

A possible threat model is a user-supplied field length in a client/server protocol that gets decoded using unsafe
operations for efficiency.

The exploit code along with instructions to execute it is located in the `code-flow-redirection/` directory.


## Code injection POC

This proof of concept shows how an array is cast to a slice without proper length checks, thus
creating a buffer overflow that is used to inject arbitrary code by spawning a shell using
return-oriented programming (ROP).

A possible threat model is a cast of fixed-length data to a slice without correct length checks, or
user-supplied length information in a client/server protocol.

The exploit code along with instructions to execute it is located in the `code-injection/` directory.


## Slice cast GC race condition POC

This proof of concept shows how a common, insecure casting pattern for slice types leads to a
garbage collector race condition that causes a use-after-free vulnerability.

The exploit code along with instructions to execute it is located in the `race-slice/` directory.
There is also a variant that uses only one statement to create and cast a new slice from scratch in the
`race-slice-1statement/` directory.

These exploits are similar to a race condition using interface typing that was introduced in a blog post by stalkr:
[golang data races to break memory safety](https://blog.stalkr.net/2015/04/golang-data-races-to-break-memory-safety.html).
It is contained in the `race-interface/` directory.


## Escape analysis flaw POC

This proof of concept shows how a common, insecure casting pattern for slice types leads to a
flawed escape analysis that creates a dangling pointer vulnerability.

The exploit code along with instructions to execute it is located in the `escape-analysis/` directory. Similar to the
GC race POC, there is a variant with only one statement in the `escape-analysis-1statement/` directory.


## Architecture-dependent struct cast POC

This proof of concept shows how architecture-dependent types within a struct type can cause
alignment issues and thus buffer overflow vulnerabilities when structs are casted in-place using
`unsafe`.

The exploit code along with instructions to execute it is located in the `alignment/` directory.


## Go-fuse patch

The `go-fuse/` directory contains a POC exploiting a bug in the github.com/hanwen/go-fuse library, as well as a patch
for the vulnerability that was already submitted upstream.
