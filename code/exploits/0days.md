# 0days

## go-fuse - toSlice

github.com/hanwen/go-fuse/v2/fuse/misc.go : 70.0

```
func toSlice(dest *[]byte, ptr unsafe.Pointer, byteCount uintptr) {
	h := (*reflect.SliceHeader)(unsafe.Pointer(dest))
	*h = reflect.SliceHeader{
		Data: uintptr(ptr),
		Len:  int(byteCount),
		Cap:  int(byteCount),
	}
}
```

toSlice würde denke ich immer byteCount Bytes in dest schreiben / lesen, d.h. der Benutzer müsste aufpassen dass ptr tatsächlich genau byteCount groß ist. Das ist denke ich eine handfeste Vulnerability.

Aber toSlice wird im Package nicht benutzt und ist auch nicht exported.


## go-fuse - BatchForget

Fuse benutzt außerdem ein Message System. Bei BatchForget wird ein SliceHeader für ForgetOne Messages erstellt, der aus request Input Bytes liest. Die Anzahl Bytes, die gelesen wird, wird auch im Request übergeben. Allerdings prüft die Funktion auch ob im Request genug Daten vorhanden sind, bevor sie daraus (unsafe) gelesen werden.

Wow - der Check erstellt nur eine Log-Meldung, bricht die Funktion aber nicht ab!! It's game time.

```
// doBatchForget - forget a list of NodeIds
func doBatchForget(server *Server, req *request) {
    in := (*_BatchForgetIn)(req.inData)
    wantBytes := uintptr(in.Count) * unsafe.Sizeof(_ForgetOne{})
    if uintptr(len(req.arg)) < wantBytes {
        // We have no return value to complain, so log an error.
        log.Printf("Too few bytes for batch forget. Got %d bytes, want %d (%d entries)",
                   len(req.arg), wantBytes, in.Count)
                   
        //JL: hier müsste nun ein Return oder Panic stehen!!
    }

    //JL: h ist ein Header auf args mit Länge in.Count (zu kurz, wie oben sogar getestet wurde)
    h := &reflect.SliceHeader{
        Data: uintptr(unsafe.Pointer(&req.arg[0])),
        Len:  int(in.Count),
        Cap:  int(in.Count),
    }

    //JL: forgets ist jetzt eine Liste von zu vielen _ForgetOne Elementen für die req.arg []byte Daten auf
    //die der Header von forgets zeigt
    forgets := *(*[]_ForgetOne)(unsafe.Pointer(h))
    
    //JL: ist in.Count zu groß für req.arg, so lesen wir nun über req.arg hinaus
    for i, f := range forgets {
        if server.opts.Debug {
            //JL: hier wird von einer Adresse mit offset auf f, also ggf. bereits außerhalb von req.arg
            //gelesen. Das ist vielleicht ein Information Leak?! Aber die Zeile wird nur im Debug Modus
            //ausgeführt, und auch nicht an den Client zurückgesendet
            log.Printf("doBatchForget: rx %d %d/%d: FORGET i%d {Nlookup=%d}",
                    req.inHeader.Unique, i+1, len(forgets), f.NodeId, f.Nlookup)
        }
        
        //JL: mit continue können wir vermutlich wenig sinnvolles machen
        if f.NodeId == pollHackInode {
            continue
        }
        
        //JL: hier wird auch auf f zugegriffen, aber als CbV wird vermutlich bereits hier ein Segfault
        //auftreten.
        server.fileSystem.Forget(f.NodeId, f.Nlookup)
    }
}
```

Das Problem ist, dass der Input in go-fuse ja durch den Kernel erzeugt wird, go-fuse liest aus dem `/dev/fuse` Device. Man kann denke ich schon davon ausgehen, dass das FUSE Kernelmodul nicht weniger Daten in arg für batchForget sendet, als in in.Count stünde. Selbst wenn, würde go-fuse einfach mehr Daten aus `/dev/fuse` lesen. Das ist jedenfalls kein Speicherabschnitt des Programms, das go-fuse nutzt, und selbst wenn würden die Daten nirgends hingeschrieben werden.

Somit wirkt das ganze nicht so sehr problematisch.

Falls go-fuse nicht direkt als Server für das FUSE Kernel Modul genutzt würde, sondern hinter einem Proxy, könnte das Proxy-Programm den Input passend craften. Aber dafür müsste man zunächst die Programme passend mounten, und wenn man das kann kann man ohnehin beliebigen Code ausführen.

Die beiden Top500-Projekte, die go-fuse nutzen (attic-labs/noms und pachyderm/pachyderm) nutzen go-fuse jedenfalls nicht als Proxy, sondern als langweilige Standard-Server-Implementierung. Rg zeigt, dass in diesen Projekten nicht mal ein spezielles Forget implementiert ist.


## go-packet

Pcap-Implementierung in Go. Benutzt einige C Strukturen. Mit einem CaptureInfo Objekt wird festgelegt, wie viele Bytes eingelesen werden. Die Länge schien überall korrekt genutzt zu werden.


## go.etcd.io bbolt

Die Deserialisierung liest aus einem Byte-Buffer den Count der Elemente ein, die danach noch einzulesen sind, und intialisiert dann einen Slice mit diesem Count und einem Data-Pointer auf den buffer. Wenn man nun also die serialisierten Daten so verändert, dass die Zahl sehr groß ist, umfasst der Slice evtl. mehr Elemente als der buffer groß war.

Der Slice (Typ pgids -> []uint64) wird anschließend in einen neuen, safe erzeugten, Slice mit der "korrekten" Länge (in dem Fall die gefakte Länge) kopiert. Hierbei würden nun die Daten, die hinter dem Buffer im Speicher lagen, in diese Kopie kopiert.

Anschließend wird freelist.readIDs aufgerufen und die Elemente des kopierten Slices eingelesen. Die Funktion kopiert einfach das Slice in die freelist struct: freelist.ids.

Ich bin unsicher, ob man hier etwas exploiten kann - evtl. kann man die freelist.ids mit korrupten Daten füllen, aber einen RIP verändern oder die Daten auch nur ausgeben scheint man zunächst nicht zu können.
