# Go-fuse vulnerability

Fuse benutzt außerdem ein Message System. Bei BatchForget wird ein SliceHeader für ForgetOne Messages erstellt, der aus 
request Input Bytes liest. Die Anzahl Bytes, die gelesen wird, wird auch im Request übergeben. Allerdings prüft die 
Funktion auch ob im Request genug Daten vorhanden sind, bevor sie daraus (unsafe) gelesen werden.

```
// doBatchForget - forget a list of NodeIds
func doBatchForget(server *Server, req *request) {
    in := (*_BatchForgetIn)(req.inData)
    wantBytes := uintptr(in.Count) * unsafe.Sizeof(_ForgetOne{})
    if uintptr(len(req.arg)) < wantBytes {
        // We have no return value to complain, so log an error.
        log.Printf("Too few bytes for batch forget. Got %d bytes, want %d (%d entries)",
                   len(req.arg), wantBytes, in.Count)
                   
        //JL: hier müsste nun ein Return oder Panic stehen!!
    }

    //JL: h ist ein Header auf args mit Länge in.Count (zu kurz, wie oben sogar getestet wurde)
    h := &reflect.SliceHeader{
        Data: uintptr(unsafe.Pointer(&req.arg[0])),
        Len:  int(in.Count),
        Cap:  int(in.Count),
    }

    //JL: forgets ist jetzt eine Liste von zu vielen _ForgetOne Elementen für die req.arg []byte Daten auf
    //die der Header von forgets zeigt
    forgets := *(*[]_ForgetOne)(unsafe.Pointer(h))
    
    //JL: ist in.Count zu groß für req.arg, so lesen wir nun über req.arg hinaus
    for i, f := range forgets {
        if server.opts.Debug {
            //JL: hier wird von einer Adresse mit offset auf f, also ggf. bereits außerhalb von req.arg
            //gelesen. Das ist vielleicht ein Information Leak?! Aber die Zeile wird nur im Debug Modus
            //ausgeführt, und auch nicht an den Client zurückgesendet
            log.Printf("doBatchForget: rx %d %d/%d: FORGET i%d {Nlookup=%d}",
                    req.inHeader.Unique, i+1, len(forgets), f.NodeId, f.Nlookup)
        }
        
        //JL: mit continue können wir vermutlich wenig sinnvolles machen
        if f.NodeId == pollHackInode {
            continue
        }
        
        //JL: hier wird auch auf f zugegriffen, aber als CbV wird vermutlich bereits hier ein Segfault
        //auftreten.
        server.fileSystem.Forget(f.NodeId, f.Nlookup)
    }
}
```

Das Problem ist, dass der Input in go-fuse ja durch den Kernel erzeugt wird, go-fuse liest aus dem `/dev/fuse` Device. 
Man kann denke ich schon davon ausgehen, dass das FUSE Kernelmodul nicht weniger Daten in arg für batchForget sendet, 
als in in.Count stünde. Selbst wenn, würde go-fuse einfach mehr Daten aus `/dev/fuse` lesen. Das ist jedenfalls kein 
Speicherabschnitt des Programms, das go-fuse nutzt, und selbst wenn würden die Daten nirgends hingeschrieben werden.

Somit wirkt das ganze nicht so sehr problematisch.

Falls go-fuse nicht direkt als Server für das FUSE Kernel Modul genutzt würde, sondern hinter einem Proxy, könnte das 
Proxy-Programm den Input passend craften. Aber dafür müsste man zunächst die Programme passend mounten, und wenn man das 
kann kann man ohnehin beliebigen Code ausführen.

Die beiden Top500-Projekte, die go-fuse nutzen (attic-labs/noms und pachyderm/pachyderm) nutzen go-fuse jedenfalls nicht 
als Proxy, sondern als langweilige Standard-Server-Implementierung. Rg zeigt, dass in diesen Projekten nicht mal ein 
spezielles Forget implementiert ist.
