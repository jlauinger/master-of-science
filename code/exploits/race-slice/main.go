package main

import (
  "fmt"
  "unsafe"
  "reflect"
  "bufio"
  "os"
  "time"
)

func main() {
  go heapHeapHeap()
  go readAndHaveFun()

  for {}
}

func unsafeStringToBytes(s *string) []byte {
  // WHAT A RANDOM SNIPPET, NOT AT ALL LIKE go.uber.org/thriftrw/wire/unsafe.go:33.0 :D
  sh := (*reflect.StringHeader)(unsafe.Pointer(s))
  sliceHeader := &reflect.SliceHeader{
    Data: sh.Data,
    Len:  sh.Len,
    Cap:  sh.Len,
  }

  // CHANGE:
  time.Sleep(0 * time.Nanosecond)

  return *(*[]byte)(unsafe.Pointer(sliceHeader))
}

func heapHeapHeap() {
  var a *[]byte
  for {
    tmp := make([]byte, 1000000, 1000000)
    a = &tmp
  }
  _ = a
}

func readAndHaveFun() {
  reader := bufio.NewReader(os.Stdin)
  count := 1
  var firstChar byte

  for {
    s, _ := reader.ReadString('\n')
    if (len(s) == 0) {
      continue
    }
    firstChar = s[0]

    // HERE BE DRAGONS
    bytes := unsafeStringToBytes(&s)

    _, _ = reader.ReadString('\n')

    if len(bytes) > 0 && bytes[0] != firstChar {
      fmt.Printf("win! after %d iterations\n", count)
      os.Exit(0)
    }

    count++
  }
}
