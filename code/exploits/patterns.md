# Patterns

- convert to `*[reallyBig]byte` and then slice down to size https://github.com/golang/go/issues/37805
- Note also that I think you have to be careful about the order of the assignments of cap and len, and actually bcmills has pointed out in another example that you really ought to set Cap and Len to 0 first, then assign the pointer, then assign the corrected values (sonst: Race Condition?)


## Cast []byte zu string

```
func b2s(b []byte) string {
    return *(*string)(unsafe.Pointer(&b))
}
```

Man kann das direkt casten, weil der StringHeader kleiner ist als der SliceHeader. Man ignoriert dann das dritte Feld des SliceHeader, denn nur die beiden im StringHeader werden interpretiert sobald die Adresse als string gelesen wird.

Der Inhalt ist dann gleich weil das Data Attribut bei beiden an der ersten Stelle steht.

Da aber die `reflect` Dokumentation sagt, dass die interne Struktur sich ändern kann, ist das hier kein ganz korrektes Pattern, denn falls StringHeader in Zukunft das Data Feld nach dem Len Feld hat aber SliceHeader weiterhin davor, dann geht der direkte Cast nicht mehr.


## Cast string zu []byte

```
func s2b(s string) []byte {
    var b []byte
    sh = (*reflect.StringHeader)(unsafe.Pointer(&s))
    bh = (*reflect.SliceHeader)(unsafe.Pointer(&b))
    bh.Len = sh.Len
    bh.Cap = sh.Cap
    bh.Data = sh.Data
    runtime.KeepAlive(s)
    return b
}
```

Der direkte Cast wie oben funktioniert hier nicht, weil der SliceHeader länger ist. Würde man den StringHeader direkt über unsafe pointer cast umwandeln, wäre das Cap Feld nicht gesetzt, bzw. dort würde eben anderer, evtl. gar nicht zugewiesener, Speicher genutzt werden.

Die lokale Variable b ist nötig, damit man den SliceHeader bh durch einen Cast erhalten kann. Dadurch weiß die Go runtime (durch eine Sonderbehandlung), dass in Data (Typ uintptr) actually eine Referenz steht und nicht einfach nur eine Zahl.

Wenn man den SliceHeader direkt erzeugt (siehe Exploit POC), dann könnte zwischen dem Erstellen des Headers und dem Casten des Headers in einen []byte Slices der Garbage Collector laufen und den ursprünglichen String aus dem Heap nehmen.

Wenn man das runtime.KeepAlive am Ende weglässt, könnte ebenso der String bereits collected sein.

Mit den neu eingeführten `unsafeheader.Slice` und `unsafeheader.String` wird statt `uintptr` `unsafe.Pointer` verwendet. Dadurch weiß die Runtime zu jeder Zeit, dass es sich um eine Referenz handelt und der GC entfernt den Wert nicht.
