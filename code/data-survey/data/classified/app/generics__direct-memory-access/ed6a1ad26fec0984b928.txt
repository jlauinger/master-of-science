Module: gorgonia.org/tensor
Version: v0.9.6

Package: gorgonia.org/tensor
File: array_getset.go
Line: 72

Imported (possibly among others) by: gorgonia/gorgonia

Label 1 (What is happening?): direct-memory-access
Label 2 (For what purpose?): generics

--------------------------------------------------------------
Snippet line:

		val := reflect.NewAt(a.t.Type, unsafe.Pointer(want))

--------------------------------------------------------------
+/- 5 lines context:

		a.SetUnsafePointer(i, xv)
	default:
		xv := reflect.ValueOf(x)
		want := unsafe.Pointer(uintptr(a.Ptr) + uintptr(i)*a.t.Size())
		val := reflect.NewAt(a.t.Type, unsafe.Pointer(want))
		val = reflect.Indirect(val)
		val.Set(xv)
	}
}


--------------------------------------------------------------
+/- 100 lines context:

// Code generated by genlib2. DO NOT EDIT.

package tensor

import (
	"reflect"
	"unsafe"

	"github.com/pkg/errors"
)

// Set sets the value of the underlying array at the index i.
func (a *array) Set(i int, x interface{}) {
	switch a.t.Kind() {
	case reflect.Bool:
		xv := x.(bool)
		a.SetB(i, xv)
	case reflect.Int:
		xv := x.(int)
		a.SetI(i, xv)
	case reflect.Int8:
		xv := x.(int8)
		a.SetI8(i, xv)
	case reflect.Int16:
		xv := x.(int16)
		a.SetI16(i, xv)
	case reflect.Int32:
		xv := x.(int32)
		a.SetI32(i, xv)
	case reflect.Int64:
		xv := x.(int64)
		a.SetI64(i, xv)
	case reflect.Uint:
		xv := x.(uint)
		a.SetU(i, xv)
	case reflect.Uint8:
		xv := x.(uint8)
		a.SetU8(i, xv)
	case reflect.Uint16:
		xv := x.(uint16)
		a.SetU16(i, xv)
	case reflect.Uint32:
		xv := x.(uint32)
		a.SetU32(i, xv)
	case reflect.Uint64:
		xv := x.(uint64)
		a.SetU64(i, xv)
	case reflect.Uintptr:
		xv := x.(uintptr)
		a.SetUintptr(i, xv)
	case reflect.Float32:
		xv := x.(float32)
		a.SetF32(i, xv)
	case reflect.Float64:
		xv := x.(float64)
		a.SetF64(i, xv)
	case reflect.Complex64:
		xv := x.(complex64)
		a.SetC64(i, xv)
	case reflect.Complex128:
		xv := x.(complex128)
		a.SetC128(i, xv)
	case reflect.String:
		xv := x.(string)
		a.SetStr(i, xv)
	case reflect.UnsafePointer:
		xv := x.(unsafe.Pointer)
		a.SetUnsafePointer(i, xv)
	default:
		xv := reflect.ValueOf(x)
		want := unsafe.Pointer(uintptr(a.Ptr) + uintptr(i)*a.t.Size())
		val := reflect.NewAt(a.t.Type, unsafe.Pointer(want))
		val = reflect.Indirect(val)
		val.Set(xv)
	}
}

// Get returns the ith element of the underlying array of the *Dense tensor.
func (a *array) Get(i int) interface{} {
	switch a.t.Kind() {
	case reflect.Bool:
		return a.GetB(i)
	case reflect.Int:
		return a.GetI(i)
	case reflect.Int8:
		return a.GetI8(i)
	case reflect.Int16:
		return a.GetI16(i)
	case reflect.Int32:
		return a.GetI32(i)
	case reflect.Int64:
		return a.GetI64(i)
	case reflect.Uint:
		return a.GetU(i)
	case reflect.Uint8:
		return a.GetU8(i)
	case reflect.Uint16:
		return a.GetU16(i)
	case reflect.Uint32:
		return a.GetU32(i)
	case reflect.Uint64:
		return a.GetU64(i)
	case reflect.Uintptr:
		return a.GetUintptr(i)
	case reflect.Float32:
		return a.GetF32(i)
	case reflect.Float64:
		return a.GetF64(i)
	case reflect.Complex64:
		return a.GetC64(i)
	case reflect.Complex128:
		return a.GetC128(i)
	case reflect.String:
		return a.GetStr(i)
	case reflect.UnsafePointer:
		return a.GetUnsafePointer(i)
	default:
		at := unsafe.Pointer(uintptr(a.Ptr) + uintptr(i)*a.t.Size())
		val := reflect.NewAt(a.t.Type, at)
		val = reflect.Indirect(val)
		return val.Interface()
	}
}

// Memset sets all values in the array.
func (a *array) Memset(x interface{}) error {
	switch a.t {
	case Bool:
		if xv, ok := x.(bool); ok {
			data := a.Bools()
			for i := range data {
				data[i] = xv
			}
			return nil
		}

	case Int:
		if xv, ok := x.(int); ok {
			data := a.Ints()
			for i := range data {
				data[i] = xv
			}
			return nil
		}

	case Int8:
		if xv, ok := x.(int8); ok {
			data := a.Int8s()
			for i := range data {
				data[i] = xv
			}
			return nil
		}

	case Int16:
		if xv, ok := x.(int16); ok {
			data := a.Int16s()
			for i := range data {
				data[i] = xv
			}
			return nil
		}

	case Int32:
		if xv, ok := x.(int32); ok {
			data := a.Int32s()
			for i := range data {
				data[i] = xv
			}
			return nil
		}


