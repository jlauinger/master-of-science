%% ---------------------------------------------------------------------------------------------------------------------

\chapter{\textit{go-geiger}: Identification of Unsafe Usage}\label{ch:go-geiger}

This chapter presents \toolGeiger{}, a tool to find usages of the \unsafe{} \acrshort{API} in Go packages and their
dependencies.
Furthermore, an empirical study on \unsafe{} usage in open-source projects using \toolGeiger{} is shown, and a novel
data set of labeled samples of \unsafe{} code is described.
Figure~\ref{fig:outline4} shows which parts of the contributions of this thesis are given in this chapter.

\input{assets/figures/chapter4/outline4.tex}


%% ---------------------------------------------------------------------------------------------------------------------

\section{Design}\label{sec:go-geiger:design}

The novel tool \toolGeiger{} is designed to identify usages of the \unsafe{} \acrshort{API} in Go source code.
In contrast to existing tools like \toolGosec{}, it includes the dependencies of Go packages in the analysis, which
gives a much better picture of possible \unsafe{} usages.
It is inspired by \toolCargoGeiger{}\footnote{\url{https://github.com/rust-secure-code/cargo-geiger}}, a similar tool
for detecting the use of unsafe code blocks in Rust programs.
Figure~\ref{fig:go-geiger-architecture} shows the architecture of \toolGeiger{}.

\input{assets/figures/chapter4/go-geiger-architecture.tex}

First, the dependency tree of the packages that are given for analysis is built.
Then, the sources of all the packages in this tree are parsed, and the resulting abstract syntax tree (\acrshort{AST})
is inspected.
Within the \acrshort{AST}, usages of the \unsafe{} \acrshort{API} are identified.
Each usage is assigned a tuple of labels consisting of \textit{match type} and \textit{context type}.
The match type represents the part of the \unsafe{} \acrshort{API} that is used.
It can be either of the four \unsafe{} package members \textit{Pointer}, \textit{Sizeof}, \textit{Offsetof}, and
\textit{Alignof}, the \textit{reflect} package fields \textit{SliceHeader} and \textit{StringHeader}, or the
\textit{uintptr} keyword.
The context type indicates the functional part of code that the usage is found in.
It can be either an \textit{assignment}, a \textit{call} of a function, a function \textit{parameter} definition, or a
\textit{variable} definition.
If the context can not be assigned to one of these four options, then it is set to \textit{other}.
This context allows to filter the search for \unsafe{} usages to particular functional code positions.
There is a \toolGeiger{} command line parameter to request this filtering.
For example, it is possible to count only \unsafe{} usages that are used within parameters of function calls.
After the \unsafe{} usages are identified, they are counted.
For this, it is necessary to take care of package deduplication.
If a particular package exists in the dependency tree multiple times and is reachable on different paths, it must still
be counted only once when calculating the sum of \unsafe{} usages in a package's dependencies.
This is because the package does not get any less safe by including the same code multiple times, the code is already
part of the resulting program.
Finally, the analysis results are shown to the user.
It is possible to output the \unsafe{} usage counts as well as the lines of code containing the usages.

The source code and documentation of \toolGeiger{} is available on
\github{}\footnote{\url{https://github.com/jlauinger/go-geiger}}.
It can be installed using the standard Go \acrshort{CLI} tool.
To execute it, append the package names that should be checked as parameters.
For example, to examine a local package for \unsafe{} usages run \textit{go-geiger ./my/package}.
There is no limitation on the number of packages that can be supplied as parameters.
Figure~\ref{fig:go-geiger-screenshot} shows a screenshot of \toolGeiger{}.
It presents the analyis results for the \textit{go-geiger} source code itself.
The output is truncated is missing parts of the table with \unsafe{} counts, which have been excluded to decrease the
space needed to display the figure.

\input{assets/images/chapter4/go-geiger-screenshot.tex}

The output shown in Figure~\ref{fig:go-geiger-screenshot} is composed of three parts.
The first is a table showing the \unsafe{} usage counts for each package in the dependency tree for the packages
given for analysis.
The first column indicates the total number of usages in the package including all its dependencies.
The second column shows the number for the package alone, without the dependencies.
The heading for this column is \textit{local package}.
Next, there are five columns with individual usage counts for the four possible usage contexts described above,
\textit{variable}, \textit{parameter}, \textit{assignment}, \textit{call}, as well as \textit{other} for all matches
that could not be assigned to any of them.
These columns add up to the \textit{local package} count.
Finally, the import path for the package is given to identify it.
Lines that are printed in green (the last \checkNum{two} lines in Figure~\ref{fig:go-geiger-screenshot}) represent
packages with no local \unsafe{} usages.
Red lines (e.g. the \checkNum{seventh} line) are packages that directly contain \unsafe{} code, and white lines indicate
that the package does not contain \unsafe{} usages itself but instead introduces them through its dependencies.
After the table, there is a summary of the number of packages belonging into these three categories green, red, and
white, and finally a legend for the colors.


%% ---------------------------------------------------------------------------------------------------------------------

\section{Implementation}\label{sec:go-geiger:implementation}

The identification of the dependency tree for the packages to analyze, as well as the parsing of the source code is done
using the standard Go compiler toolchain.
It is accessable using the \textit{packages}
\acrshort{API}\footnote{\url{https://pkg.go.dev/golang.org/x/tools/go/packages}}.
Similarly, the inspection of the \acrshort{AST} is done using the \acrshort{API} available though the \textit{ast}
package in Go\footnote{\url{https://golang.org/pkg/go/ast/}}.

To find \unsafe{} usages corresponding to the different match types shown in Figure~\ref{fig:go-geiger-architecture},
the \acrshort{AST} is filtered for \textit{SelectorExpr} and \textit{Ident} nodes.
The first represent selector expressions, which indicate possible access of a member of another package, like in a usage
of \textit{unsafe.Pointer}.
The second is used to find instances of \textit{uintptr}.
In both cases the concrete identifier names in the \acrshort{AST} nodes are checked to distinguish \unsafe{} usages from
arbitrary other field accesses.
The context type is determined by going up in the \acrshort{AST} starting at the expression node corresponding to a
given \unsafe{} usage.
For example, an \unsafe{} usage is considered part of the \textit{assignment} context type if it is a descendent of
either an \textit{AssignStmt}, \textit{CompositeLit}, or \textit{ReturnStmt} node.
The \textit{call}, \textit{parameter}, and \textit{variable} classes correspond to \textit{CallExpr}, \textit{FuncDecl},
and \textit{GenDecl} nodes, respectively.
To achieve an effective assignment of the context type, the order in which the different types are checked is important.
This is because an \unsafe{} usage have reason to be included in several context types such as \textit{call} and
\textit{assignment} in an example like \textit{x := f(unsafe.Pointer(y))}.

The \unsafe{} usage counts are first collected for each package.
A cache is used to avoid analyzing the same package multiple times if it is present several times in the dependency
tree.
When the usage count including dependencies is calculated, \toolGeiger{} starts with the root packages that were
requested for analysis by the user, and recursively calculates the respective counts.
Again, the cache is used to avoid summing up multiple times.
This approach is a depth-first traversal of the dependency tree.

Automated acceptance testing verifies that \toolGeiger{} works as intended.
The test is done by running \toolGeiger{} on a test fixture package with a known number of \unsafe{} usages.
Then, the output is checked for the expected usage counts.


%% ---------------------------------------------------------------------------------------------------------------------

\section{Evaluation}\label{sec:go-geiger-evaluation}

To evaluate \toolGeiger{} on real-world code, it is used to gather empirical data about the usage of \unsafe{} in
popular open-source Go projects.
This section presents a study which was designed to answer the following research questions:

\begin{enumerate}[left=0.5cm, label={RQ\arabic*}]
    \item How prevalent is \unsafe{} in Go projects? \label{rq:prevalApp}
    \item How deep are \unsafe{} code packages buried in the dependency tree? \label{rq:depsDepth}
    \item Which \unsafe{} keywords are used most? \label{rq:distTypes}
    \item Is there a correlation between \unsafe{} usage and common project metrics such as age or popularity? \label{rq:popularity}
    \item How does the use of \unsafe{} change over time? \label{rq:changeTime}
    \item Does \toolGeiger{} provide additional insights into \unsafe{} usage compared to existing linter tools? \label{rq:linterComparison}
    \item Which \unsafe{} operations are used in practice, and for what purpose? \label{rq:purpose}
\end{enumerate}

The following subsections first discuss how the data for this study was gathered and then answer research
questions~\ref{rq:prevalApp} to~\ref{rq:linterComparison}.
Then, Section~\ref{sec:go-geiger:labeled-dataset} presents the answer to~\ref{rq:purpose}.


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Data Set}\label{subsec:go-geiger:evaluation:data-set}

To build a data set of \unsafe{} usages, first the top \projsTotal{} most-starred open-source Go projects available on
\github{} were downloaded.
This initial download was done on \checkNum{May 27, 2020}.
Since \toolGeiger{} is specifically built to analyze the project dependencies, all projects that do not support the Go
modules system were then removed from the set.
This is necessary to ensure that all dependencies can be automatically resolved and the respective sources are available
for analysis.
There were \projsWithoutModules{} projects that had no support for modules.
Furthermore, \projsNotCompiled{} could not be compiled and thus also had to be excluded from the data set.
Since \toolGeiger{} analyzes the \acrshort{AST}, it can not work on packages that can not be parsed.
This results in a set of \projsAnalyzed{} Go projects.
These have between \checkNum{72,988} and \checkNum{3,075} stars, with an average of \checkNum{7,860}.

As a next step, the dependency trees for all projects were built, resulting in \packagesAnalyzed{} unique packages.
These packages were then analyzed using \toolGeiger{} as well as the existing static analysis tools \toolVet{} and
\toolGosec{} to allow a comparison between the findings of these tools.
The resulting findings were stored in machine-readable \acrshort{CSV} files.
All data files as well as the data acquisition tool used to download the projects and run the analysis tools on them
are available in a data repository on \github{}\footnote{\url{https://github.com/stg-tud/unsafe_go_study_results}}.
The data set contains \uniqueUnsafeFindings unique \unsafe{} usages.


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Usages in Projects and Dependencies}\label{subsec:go-geiger:evaluation:unsafe-usage}

To attribute \unsafe{} usages to either a project (as first-party code) or one of its dependencies (as third-party
code), the root module of the project is used.
Since the data set was constructed such that all projects support the Go module system as described in the previous
section, there is a top-level \textit{go.mod} file present for each of them.
The module specified in that file is stored with the project information as its root module.
Then, packages that are part of this module are first-party project code, while packages present in the dependency tree
but not in the root module are dependencies.

By looking at \unsafe{} findings that are part of first-party packages, it is possible to determine how many projects
directly use \unsafe{} in their code.
The data shows that this is the case for \unsafeProjects{} (\percentageUnsafeProjects{}) of the \projsAnalyzed{}
projects.
However, including the complete dependency tree into the analysis reveals that \unsafePackages{}
(\percentageUnsafePackages{}) of the \packagesAnalyzed{} unique packages contain at least one \unsafe{} usage.
This results in \unsafeTransitiveWithDependencies{} (\percentageUnsafeTransitiveWithDependencies{}) of the projects
transitively importing \unsafe{} usages.
These numbers are taken without the Go standard library.
All analyzed projects import this library and it contains \unsafe{} usages, which means that including it
\checkNum{100\%} of the projects would transitively use \unsafe{}.
This answers research question~\ref{rq:prevalApp} about the prevalence of \unsafe{} in Go projects.
Because the standard library is developed by the Go core team, we assume that it is well audited and safe to use.
Since there is no way to exclude it from a project anyways, the analysis presented in this study is more meaningful
when the standard library is not causing a project to be counted as using \unsafe{}.

\begin{tcolorbox}[boxsep=3pt, enlarge top by=5pt, title=Answer to~\ref{rq:prevalApp}]
    About \percentageUnsafeProjectsRounded{} of projects contain \unsafe{} usages in their first-party code.
    Approximately \percentageUnsafeTransitiveWithDependenciesRounded{} of projects transitively import at least one
    third-party dependency package with \unsafe{} usages.
\end{tcolorbox}

To answer research question~\ref{rq:depsDepth} about how deep in the dependency tree packages using \unsafe{} are
usually located, the import depth of all packages used by a project is determined.
Import depth denotes the minimum depth of a package in the dependency tree of a particular project, which is the
shortest path from the project root module to the package.
Thus, all packages included in the root module have an import depth of \checkNum{zero}.
Packages imported be those have a depth of \checkNum{one}, and so on.
The depth is calculated using breadth-first search on the dependency tree, which saves time when packages are imported
many times because only the mimimum depth is important here.
Figure~\ref{fig:unsafe-import-depth} presents a heatmap plot of the number of packages containing \unsafe{} usages by
their import depth.
The y-axis denotes the depth, the color intensity shows the number of \unsafe{} packages at a given depth, and the
x-axis represents the \projsAnalyzed{} analyzed projects.
On the left hand side, next to the heat map, the horizontal bar chart visualizes the total number of packages at each
import depth summed up over all projects.
Packages that do not contain any \unsafe{} usages are not shown in the graph at all as they are irrelevant for
answering~\ref{rq:depsDepth}.

\input{assets/plots/chapter4/unsafe-import-depth.tex}

The graph shows that most packages containing \unsafe{} usages are imported fairly early, however not directly at the
first level.
The average depth is \averageUnsafeImportDepth{} with a standard deviation of \stdUnsafeImportDepth{}.
The general import depth of all packages, containing \unsafe{} of not, is similar if slightly lower at
\averageGeneralImportDepth{}.
While the numbers are fairly low, the number of packages at each level of import depth increases exponentially.
Thus, while being possible it is hard for developers to manually audit dependency packages for \unsafe{} usages.
The novel \toolGeiger{} tool helps by quickly identifying the packages containing \unsafe{}, therefore it is possible to
conduct a focused review of the \unsafe{} code without wasting time on identifying the relevant packages for it.
Only the first level of dependencies contains the packages that the project developers added themselves, thus they are
obvious to the developers.
The data set shows that \levelOneImportedUnsafePackagesCount{} (\levelOneImportedUnsafePackagesShare{}) of the
\levelOneOmportedPackagesCount{} packages imported at the first level contain at least one \unsafe{} usage.
This further shows that the majority of \unsafe{} code is introduced further down in the dependency tree.

\begin{tcolorbox}[boxsep=3pt, enlarge top by=5pt, title=Answer to~\ref{rq:depsDepth}]
    Most imported packages with at least one \unsafe{} usage are located around a depth of
    \averageUnsafeImportDepthRounded{} in the dependency tree.
\end{tcolorbox}

Research question~\ref{rq:distTypes} is about which \unsafe{} tokens are used the most.
As described in Section~\ref{sec:go-geiger:design}, \toolGeiger{} identifies usages of the four members of the \unsafe{}
package, the \textit{reflect.SliceHeader} and \textit{reflect.StringHeader} types, and \textit{uintptr}.
Figure~\ref{fig:unsafe-tokens-distribution} shows the distribution of these \unsafe{} types in the data set of Go
projects.
The individual counts sum up to the total number of \uniqueUnsafeFindings{} \unsafe{} findings in the data set.

\input{assets/plots/chapter4/distribution-unsafe-types.tex}

The data shows that \textit{uintptr} is the most common \unsafe{} token, with \checkNum{99,741} findings.
Next, \textit{unsafe.Pointer} has a similarly high prevalence of \checkNum{94,431} samples.
These two lead the usage counts by far, with the next being \textit{unsafe.Sizeof} at only \checkNum{3,667} usages and
all other token types found less than \checkNum{1,000} times.
With a mere \checkNum{8} usages found, \textit{unsafe.Alignof} is the most rare.

\begin{tcolorbox}[boxsep=3pt, enlarge top by=5pt, title=Answer to~\ref{rq:distTypes}]
    In the wild, uintptr and unsafe.Pointer are orders of magnitude more common than other unsafe usages.
\end{tcolorbox}


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Influence of Age and Popularity}\label{subsec:go-geiger:evaluation:popularity}

This subsection answers research question~\ref{rq:popularity} about whether there is a correlation between \unsafe{}
usage and the common projects metrics age and popularity.
Popularity is measured by the number of stars and number of forks that a project has on \github{}.
Figure~\ref{fig:correlation-popularity} presents a scatter plot showing the number of \unsafe{} usages on the x-axis and
multiple project metrics on the y-axis.
Each dot represents one project.
Red dots indicate a project's age, blue dots show the number of stars, and green dots denote the number of forks.
\todo{Add scatter plot that shows correlation between unsafe usage and project stars/forks/age using differently colored
dots. It should result in no correlation.}

\input{assets/plots/chapter4/correlation-popularity.tex}

The plot suggests that there is no correlation between either age, number of stars, nor number of forks and the number
of \unsafe{} usages in a project.

\begin{tcolorbox}[boxsep=3pt, enlarge top by=5pt, title=Answer to~\ref{rq:popularity}]
    There is no significant correlation between the number of \unsafe{} usages and a project's age, number of stars, or
    number of forks.
\end{tcolorbox}


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Change of Usage over Time}\label{subsec:go-geiger:evaluation:over-time}

The data set collected in this study contains one version of each analyzed project.
Therefore, it is not directly possible to measure the change of \unsafe{} usage in projects over time.
However, there are a number of modules that are included in several versions by different projects, which means these
modules allow an analysis of such changes in \unsafe{} usage.
To answer research question~\ref{rq:changeTime}, this subsection discusses the differences between different version of
an examplary module, \textit{golang.org/x/sys}.

The module is present in the data set with a total of \sysModuleVersions{} versions.
A subset of the versions with a fair distribution of release dates in \checkNum{2019} and \checkNum{2020}, as well as a
rather old version from \checkNum{2017} is shown in Table~\ref{tbl:unsafe-usage-over-time}.
The table shows the version identifiers alongside their release dates and number of \unsafe{} usages in the particular
version.
The module versions are ordered by their release date.

\input{assets/tables/chapter4/unsafe-usage-over-time.tex}

It is evident that there is a monotonous increase in \unsafe{} usage, with an increase from \sysModuleLeastUnsafe{} to
\sysModuleMostUnsafe{} (\sysModuleUnsafeIncrease) over the \checkNum{2.5 years} period from \checkNum{2017} to
\checkNum{2020}.
A manual analysis of the changes in the module source code shows that the increased usages of \unsafe{} in this case are
caused by additional system call \acrshort{API}s that are supported by the module.
Dispatching to the underlying system call code requires the use of \textit{unsafe.Pointer}.
Therefore, in this case more features provided by a dependency cause more \unsafe{} code to be imported into a project.

\begin{tcolorbox}[boxsep=3pt, enlarge top by=5pt, title=Answer to~\ref{rq:changeTime}]
    Changes in \unsafe{} usage in particular modules are motivated for example by new \acrshort{API} requirements and
    can be significant, with e.g. about a \sysModuleUnsafeIncreaseRounded{} increase found in the
    \textit{sys} module.
\end{tcolorbox}


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Comparison with Existing Tools}\label{subsec:go-geiger:evaluation:linters-comparison}

To evaluate the benefit \toolGeiger{} provides in comparison to existing linters for Go, its findings are put in context
with the results of \toolVet{} and \toolGosec{} in this section.
The goal of this comparison is to see whether any of those tools can achieve the same as \toolGeiger{} does.
As described in Section~\ref{sec:background:static-code-analysis}, \toolVet{} is a linter that is included as part of
the standard Go command line tool chain.
It runs a number of analysis passes to identify general problems with the source code.
There is the \textit{unsafeptr} pass, which is designed to find potential misuses of the \textit{unsafe.Pointer} type.
It is however not designed for a general identification of \unsafe{} usages.
On the other hand, \toolGosec{} is a static analysis tool with a design focused around security problems.
It is built from several rules to identify issues, one of which (\textit{\checkNum{G103}}) is simply triggered by the
presence of \unsafe{} package members and generates a warning that those usages should be audited.
Given this design, it is closer to \toolGeiger{} in the sense that it only identifies the presence of \unsafe{} without
using any logic to determine potential misuses.

To conduct the comparison, \toolVet{} and \toolGosec{} are run on the same \packagesAnalyzed{} packages that were
analyzed with \toolGeiger{}.
The results are part of the data set as well.
Then, the findings of the tools are matched using package, file name, and line number information.
Table~\ref{tbl:go-geiger-evaluation-linters} shows the results of this analysis.
The result columns are divided to show the different results for \toolVet{} and \toolGosec{}.
True positives (TP) are lines of code that were both flagged by \toolGeiger{} and the respective linter tool.
False negatives (FN) denote lines that were only flagged by \toolGeiger{}, but not by the linter.
Finally, false positives (FP) indicate that the linter flagged a line that was not identified by \toolGeiger{}.
There is no column for true negatives because the number of these is irrelevant for this analysis.
The table contains two rows that show the number of lines of code both when counting any message that \toolVet{} or
\toolGosec{} produced and when only messages related to their \unsafe{} analyses are taken into account.
The latter has more impact because comparing only those messages to the output of \toolGeiger{}, which is solely
designed around \unsafe{} usages, achieves a fairer evaluation.

\input{assets/tables/chapter4/go-geiger-evaluation-linters.tex}

The results show that there is only a very small number of true positives for \toolVet{}, but many false negatives.
This means that for most of the \unsafe{} usages \toolVet{} does not generate a warning.
When comparing any message generated by \toolVet{}, there are many false positives, however those do not exist anymore
when the analysis is restricted to \toolVet{} messages related to \unsafe{}.
This means that while \toolVet{} provides a lot of warnings that are related to other problems, it does not offer any
benefit over \toolGeiger{} for the specific task of identifying \unsafe{} usages.
For \toolGosec{}, there are a lot more true positives, but still a lot of false negatives.
About \checkNum{half} of the \toolGeiger{} results are also found by \toolGosec{}.
This is much better than \toolVet{}, but it is still not accurate.
One reason for this is that \toolGeiger{} identifies not only \textit{unsafe} packages uses, but also \textit{uintptr}
which is common as described in Section~\ref{subsec:go-geiger:evaluation:unsafe-usage}.
Similar to \toolVet{}, there are many false positives when any \toolGosec{} message is counted, but there are none when
only \unsafe{}-related messages are analyzed.
Therefore, \toolGosec{} can not detect any usages that \toolGeiger{} would miss.
It is worth noting that the numbers in Table~\ref{tbl:go-geiger-evaluation-linters} refer to lines of code rather than
\unsafe{} findings, but one line of code can contain several \unsafe{} usages.
Therefore the numbers do not add up to the same total findings discussed in
Section~\ref{subsec:go-geiger:evaluation:unsafe-usage}.

\begin{tcolorbox}[boxsep=3pt, enlarge top by=5pt, title=Answer to~\ref{rq:linterComparison}]
    The existing tools \toolVet{} and \toolGosec{} do not provide any benefit over \toolGeiger{} for the specific task
    it is designed for.
    Instead, \toolGeiger{} finds all and more of their \unsafe{}-related results.
\end{tcolorbox}


%% ---------------------------------------------------------------------------------------------------------------------

\section{Purpose of Unsafe in Practice: a Labeled Data Set}\label{sec:go-geiger:labeled-dataset}

This chapter contributes an in-depth study of unsafe usages in 10 selected open-source Go projects.
I analyzed 1000 usages in application code, and 400 usages in the standard library.
The usages are classified in two dimensions by what is happening and what is the higher-level purpose.

I analyzed the following projects.

\input{assets/tables/chapter4/dataset-projects.tex}

I selected them based on their high number of unsafe usages, and taking care of that they represent a reasonably large
diversity.
The projects contain applications based around containers and operations, chat, infrastructure as a service, data
storage, visualization, and machine learning.

When selecting samples to look at, I deliberately separated the standard library from application usages.
This is based on the results of the large-scale study shown in Chapter~\ref{ch:survey}, which show that all projects
must use the standard library, and the hypothesis that the standard library uses unsafe patterns differently.
It has to do so because the standard library takes care of low-level memory management by design.

Standard library is defined by the packages that live in the Go standard library and the \texttt{golang.org/x/sys}
module.
I took the decision to include the sys package because it contains a lot of syscall infrastructure and in general
behaves more like the standard library than application code.
It is also maintained by the core Go developer team.
Obviously, application packages is defined as packages that are not part of the standard library.

I randomly sampled 1000 snippets from application packages and 400 snippets from the standard library.
The samples are taken without duplicates in version, that is the same snippet by module, file, and line number is not
taken twice if there is a different version of the same module also available.
This is done by best effort: if the line number changes between module versions there might still be logical
duplication.
The set of deduplication is module, package, file, line number.
I only took samples that contain \texttt{unsafe.Pointer}, no other unsafe matches.

Both because there is no easy way to find out if an imported dependency is maintained by a project itself, or by a
third party, and because it gives a better picture on real unsafe usages in the industry, the unsafe samples are taken
from all dependencies.
Therefore, the snippets are not all part of packages from the ten projects, but some more packages.

I classified the samples on two dimensions.
The first shows what is being done, e.g. a cast or a pointer arithmetic.
The second dimension shows the purpose of the unsafe usage, e.g. serialization or realization of generics.

The results are shown in Table~\ref{tbl:labels-results-app} for the application code snippets, and
Table~\ref{tbl:labels-results-std} for the standard library snippets.

\input{assets/tables/chapter4/dataset-labels.tex}

I put each sample along with its classification and information about where it was taken from into its own file.
The files are put into directories whose names indicate both classification dimensions.

Here are examples and descriptions for each of the classes used to describe what is happening in an unsafe usage.

\input{assets/listings/chapter4/dataset-label-class-examples.tex}

\begin{tcolorbox}[boxsep=3pt, enlarge top by=5pt, title=Answer to~\ref{rq:purpose}]
    \checkNum{More than half} of the \unsafe{} usages in projects and 3rd party libraries are to improve efficiency via
    \unsafe{} casts.
    In the Go standard library, \checkNum{every third} use of \unsafe{} is to avoid garbage collection.
\end{tcolorbox}
