%% ---------------------------------------------------------------------------------------------------------------------

\chapter{\textit{go-safer}: Detecting Unsafe Misuses}\label{ch:go-safer}

Another major contribution of this thesis is the development of \toolSafer{}, a \toolVet{}-style, open-source linter
tool with a focus on the \unsafe{} \acrshort{API} in Go.
It can identify some of the unsafe code patterns described in Chapter~\ref{ch:unsafe-security-problems} and thus help
developers to write safer code.
This chapter describes the design and implementation of \toolSafer{}, as well as an evaluation of its effectiveness both
using the labeled data set of \unsafe{} usages presented in the previous chapter and a manual analysis of \checkNum{six}
open-source Go packages.

\input{assets/figures/chapter5/outline5.tex}


%% ---------------------------------------------------------------------------------------------------------------------

\section{Design}\label{sec:go-safer:design}

The \toolSafer{} static analysis tool is designed as a linter to identify two misuses of the \unsafe{} \acrshort{API}
that were previously undetected with existing tools such as \toolVet{} and \toolGosec{}.
The selection of the code patterns that are detected is based on the \unsafe{} usage examples identified using
\toolGeiger{} in popular open-source Go projects as described in Chapter~\ref{ch:go-geiger}, as well as the manual
analysis of possible vulnerabilities related to the use of the \unsafe{} \acrshort{API} presented in
Chapter~\ref{ch:unsafe-security-problems}.
The first is the incorrect conversion pattern between slices and strings by creating their header structures as
composite literals as described in Section~\ref{subsec:unsafe-security-problems:slice-casts:gc-race}.
Listing~\ref{lst:go-safer-sliceheader-pass} shows example code that uses this unsafe pattern.

\input{assets/listings/chapter5/go-safer-sliceheader-pass.tex}

In addition to composite literals of type \textit{reflect.SliceHeader} and \textit{reflect.StringHeader}, \toolSafer{}
analyzes accesses to fields of existing instances of these types.
When they are detected, the tool checks whether the given header structure instance was derived by cast from a real
slice or string.
If that is not the case or can not be statically inferred, for example because the header value is given as a function
parameter or return type, or there is only a declaration of the variable and type without an initialization, then the
field access is treated as potentially unsafe and \toolSafer{} generates a warning.
\toolSafer{} parses the packages to acquire the abstract syntax trees (\acrshort{AST}) for all files.
This allows the tool to run analysis steps that are independent from concrete names in the source code.
If the slice or string header types are renamed to a different type name in the source code, then field accesses to and
composite literals of the new type name are recognized just like the original types.

The second misuse that \toolSafer{} detects is a direct conversion between struct types containing incompatible types
with architecture-dependent sizes as described in
Section~\ref{subsec:unsafe-security-problems:slice-casts:escape-analysis}.
Listing~\ref{go-safer-structcast-pass} is an example of such code.

\input{assets/listings/chapter5/go-safer-structcast-pass.tex}

To identifiy this misuse, \toolSafer{} finds direct conversions between structures using the \textit{unsafe.Pointer}
type.
Then, the source and target types are compared.
If they contain a different amount of fields of the types \textit{int}, \textit{uint}, or \textit{uintptr}, a warning
is issued.
These are the types with architecture-dependent sizes available in Go.

The source code and documentation of \toolSafer{} is available on
\github{}\footnote{\url{https://github.com/jlauinger/go-safer}}.
It can be installed using the standard Go \acrshort{CLI} tool and is run with the source code packages that should be
checked as parameters.
For example, to check a local package run \textit{go-safer ./my/package}.
There is no limitation on the number of packages that can be supplied as parameters.
Figure~\ref{go-safer-screenshot} shows a screenshot of \toolSafer{} containing a few warnings about insecure slice
conversions.

\input{assets/images/chapter5/go-safer-screenshot.tex}

\toolSafer{} is based on the same foundation as \toolVet{}, therefore it supports the same command line arguments and
options.
These include amongst others the option to include a context of adjacent source code lines for each warning in the
output, or change the output format to machine-readable JSON instead of the standard output, which is designed to be
read by humans.


%% ---------------------------------------------------------------------------------------------------------------------

\section{Implementation}\label{sec:go-safer:implementation}

As mentioned in the last section, \toolSafer{} is built using the Go analysis infrastructure that is available as part
of \toolVet{}.
This allows to compose analysis steps as modular and reusable parts, which are called \textit{passes}.
Each analysis pass is run on the source code packages under analysis as a unit.
It can depend on the results of other analysis passes, which are then run before it and hand the results over to it.
The passes and their relations must form a directed acyclic graph, and the analyis infrastructure code determines the
optimal execution order and parallelism.
There are two novel analysis passes in \toolSafer{}, the \textit{sliceheader} and the \textit{structcast} pass.
Figure~\ref{fig:go-safer-architecture} shows an overview of this architecture.

\input{assets/figures/chapter5/go-safer-architecture.tex}

Parsing the source code of the packages under analysis is done using the same code as \toolVet{} uses, in fact that code
is required as a dependency for \toolSafer{}.
Then, the abstract syntax tree (\acrshort{AST}) and control flow graph (\acrshort{CFG}) of the sources are built using
existing analysis passes which the novel \toolSafer{} passes depend upon.
After all analysis passes have run, the results are also presented to the user by the same code used in \toolVet{}.
This composition using many existing parts allows to keep the required new code to a minimum, reuses well-tested pieces
of code, and allows to integrate the new \toolSafer{} features into a familiar workflow.

The \textit{sliceheader} analysis pass first receives the \acrshort{AST} and filters it for composite literals and
assignment statements.
These are given by \textit{ast.CompositeLit} and \textit{ast.AssignStmt} nodes.
Recursively going down the \textit{AST} even after a composite literal has been found ensures that \toolSafer{} also
detects such literals that are part of a bigger structure type that contains a slice header as one of its fields.
Then, the type of either the composite literal or the assignment receiver is checked.
For assignments, this is done by looking up the left hand side identifier in a typing table provided by the parser.
Since Go supports multiple assignments in one statement, there can be multiple variables on the left hand side.
In this case, \toolSafer{} checks all of them to see if any meets the conditions to trigger a warning.
To check whether the type matches either \textit{reflect.StringHeader} or \textit{reflect.SliceHeader}, the given type
is checked for assignability to the underlying structure of the header types.
This structure, as illustrated in Figure~\ref{fig:go-safer-architecture}, is one \textit{uintptr} fields and then one
or two \textit{int} fields.
Comparing to the structure instead of the name of the type makes it possible to detect type aliases to the header types
which might exist.
For example, when there is a \textit{type CustomHeader reflect.SliceHeader} definition, then \toolSafer{} will also
detect composite literals of type \textit{CustomHeader}.
A composite literal of a header type is already enough to issue a warning, but for assignments \toolSafer{} needs to
check whether the receiver variable is a slice or string header that was created by conversion from a real slice or
string.
To do this, the \acrshort{AST} assignment node is located within the \acrshort{CFG}.
Then, going backwards in the \acrshort{CFG}, the first node that assigns the value of the receiver variable is found.
This node is the effective value of the slice or string header structure at the time of the assignment under
investigation.
Finally, \toolSafer{} checks whether the right hand side value of the statement defining that value is a conversion
from an actual slice or string value.
It has to be a cast through an \textit{unsafe.Pointer} value for that.
If this is the case, then the assignment is legitimate and \toolSafer{} does not print a warning.
However, if the variable is not derived by a conversion from a slice or string, or no \acrshort{CFG} node defining the
variable can be found, then a warning is issued.
The last case is possible for example if the slice or string header is passed in as a function parameter, because then
its value can not be statically inferred with the Go analysis framework.

The \textit{structcast} pass also uses the \acrshort{AST} to find cast operations.
These are represented in the \acrshort{AST} in the same way as function calls are, so the tree is filtered for
\textit{CallExpr} nodes.
If there is a cast from some structure type to \textit{unsafe.Pointer} and then further to another structure type, then
these source and target types are analyzed.
These types can again be fetched from a type lookup table provided by the parser.
For both of them, \toolSafer{} counts the number of fields that have the types \textit{int}, \textit{uint}, and
\textit{uintptr}.
These \checkNum{three} basic types are the ones available in Go that have different sizes on varying architectures.
For example, \textit{int} is \checkNum{eight} bytes on the \textit{amd64} architecture, but only \checkNum{four} bytes
on \textit{i386}.
If the counts mismatch, then the direct cast using the \unsafe{} \acrshort{API} will likely break on some architectures,
and \toolSafer{} generates a warning.

A set of automated tests verifies that \toolSafer{} works as expected.
These tests also use the framework provided by the Go analysis infrastructure, which allows tests to be written as
individual source packages where expected warnings are given as line comments in the respective lines.
On the other hand, lines that must not trigger any warnings can either have no comment or an explit \textit{ok} comment.
This allows a fast and effective composition of new test cases.
At the same time, the test cases provide formal documentation about positive and negative examples for the code patterns
detected by \toolSafer{}.


%% ---------------------------------------------------------------------------------------------------------------------

\section{Evaluation}\label{sec:go-safer:evaluation}


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Labeled Usages}\label{subsec:go-safer:evaluation:labeled-usages}

Precision, Recall, calculated using manually labeled usages data set

\input{assets/tables/chapter5/go-safer-evaluation-dataset.tex}


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Case Studies}\label{subsec:go-safer:evaluation:case-studies}

Manual inspection of some projects, used to calculate precision / recall of go-safer

\input{assets/tables/chapter5/go-safer-evaluation-packages.tex}


%% ---------------------------------------------------------------------------------------------------------------------

\subsection{Comparison with Existing Tools}\label{subsec:go-safer:evaluation:linters-comparison}

Go vet / Gosec
