%% ---------------------------------------------------------------------------------------------------------------------

\chapter{Future Work}\label{ch:future-work}

Based on the contributions of this thesis, future work might look into the following areas.
The novel data set of manually labeled \unsafe{} usages can be used for interesting further research.
First, the code samples in the \textit{efficiency} class do not strictly require the use of \unsafe{}, but should
improve the performance of the code.
Future work could quantify by how much \unsafe{} actually increases the efficiency compared to using other, memory-safe
language features of Go.
If the benefit is small, \unsafe{} would pose an unnecessary risk that could be avoided.
Especially, a comparison with performance improvements of new Go compiler releases would be interesting to see if
simply waiting for a new version of the compiler can provide more efficient program binaries than \unsafe{} does.
Furthermore, future work could evaluate the possibility of automatically replacing such \unsafe{} usages with safe
language constructs.
The labeled data set could also be used as a training and verification data set in machine learning applications.
For example, an automated classification tool that predicts the purpose and danger of unseen \unsafe{} code patterns
could be built.
This would be valuable both for security analysts to conduct a large-scale study of \unsafe{} usages in thousands of
projects, and for software engineers to highlight particularly dangerous usages in the findings of \toolGeiger{}, as
well as ones that can be replaced with new language features.

Next, future research could focus on verification techniques for \unsafe{} Go code, such as annotations for
contracts or invariants that formalize assertions about control and data flow.
For example, \unsafe{} code that creates implicitly read-only values could be formally declared immutable, so that a
verifier can detect invalid accesses to the value.
A static verification such as the Viper framework~\cite{muller2016} would probably be preferable over a dynamic one,
because the additional runtime overhead could potentially outweigh the efficiency improvements of using \unsafe{} in the
first place.

Finally, establishing a public documentation of good and bad usage examples of the Go \unsafe{} \acrshort{API} could
help developers avoid common mistakes.
For insecure usages, it could provide an explanation of the potential vulnerability, as well as a suggestion for a
secure alternative.
Similar to \toolSafer{}, a linter could be developed to identify harmless usages of \unsafe{}, which could automatically
be flagged safe and thus be excluded from manual review.
