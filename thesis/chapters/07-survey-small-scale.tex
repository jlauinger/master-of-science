%% -----------------------------------------------------------------------------

\chapter{In-depth, small-scale study of unsafe code usages}\label{ch:survey-small-scale}

This chapter provides an in-depth study of unsafe usages in 10 selected open-source Go projects.
I analyzed 1000 usages in application code, and 400 usages in the standard library.
The usages are classified in two dimensions by what is happening and what is the higher-level purpose.


%% -----------------------------------------------------------------------------

\section{Methodology}\label{sec:survey-small-methodology}

I analyzed the following projects.
They are a subset of Table~\ref{tbl:projects}.

\begin{table}[h]
    \centering
    \caption{Selected projects for in-depth, small-scale study}
    \label{tbl:survey-small-projects}
    \begin{tabular}{llrrll}
        \toprule
        {}  &                                               Name &  Stars &  Forks & Last Pushed &   Revision \\
        \midrule
        1   &                              kubernetes/kubernetes &  66512 &  23806 & 2020-05-28 &  fb9e1946b0 \\
        2   &                       mattermost/mattermost-server &  18277 &   4157 & 2020-05-28 &  e83cc7357c \\
        3   &                                    rancher/rancher &  14344 &   1758 & 2020-05-28 &  56a464049e \\
        4   &                                   weaveworks/scope &   4354 &    554 & 2020-05-26 &  bf90d56f0c \\
        5   &                                          rook/rook &   7208 &   1472 & 2020-05-28 &  ff90fa7098 \\
        6   &                                      elastic/beats &   8852 &   3207 & 2020-05-28 &  df6f2169c5 \\
        7   &                                hashicorp/terraform &  22151 &   5729 & 2020-05-28 &  01f91316da \\
        8   &                                      cilium/cilium &   5501 &    626 & 2020-05-28 &  9b0ae85b5f \\
        9   &                                       grafana/loki &   9537 &    922 & 2020-05-28 &  10a1f28a85 \\
        10  &                                  gorgonia/gorgonia &   3373 &    301 & 2020-05-24 &  5fb5944d4a \\
        \bottomrule
    \end{tabular}
\end{table}

I selected them based on their high number of unsafe usages, and taking care of that they represent a reasonably large
diversity.
The projects contain applications based around containers and operations, chat, infrastructure as a service, data
storage, visualization, and machine learning.

When selecting samples to look at, I deliberately separated the standard library from application usages.
This is based on the results of the large-scale study shown in Chapter~\ref{ch:survey}, which show that all projects
must use the standard library, and the hypothesis that the standard library uses unsafe patterns differently.
It has to do so because the standard library takes care of low-level memory management by design.

Standard library is defined by the packages that live in the Go standard library and the \texttt{golang.org/x/sys}
module.
I took the decision to include the sys package because it contains a lot of syscall infrastructure and in general
behaves more like the standard library than application code.
It is also maintained by the core Go developer team.
Obviously, application packages is defined as packages that are not part of the standard library.

I randomly sampled 1000 snippets from application packages and 400 snippets from the standard library.
The samples are taken without duplicates in version, that is the same snippet by module, file, and line number is not
taken twice if there is a different version of the same module also available.
This is done by best effort: if the line number changes between module versions there might still be logical
duplication.
The set of deduplication is module, package, file, line number.
I only took samples that contain \texttt{unsafe.Pointer}, no other unsafe matches.

Both because there is no easy way to find out if an imported dependency is maintained by a project itself, or by a
third party, and because it gives a better picture on real unsafe usages in the industry, the unsafe samples are taken
from all dependencies.
Therefore, the snippets are not all part of packages from the ten projects, but some more packages.
They are shown in Table~\ref{tbl:survey-small-packages-app} and Table~\ref{tbl:survey-small-packages-std}.


%% -----------------------------------------------------------------------------

\section{Classification results}\label{sec:survey-small-classification}

I classified the samples on two dimensions.
The first shows what is being done, e.g. a cast or a pointer arithmetic.
The second dimension shows the purpose of the unsafe usage, e.g. serialization or realization of generics.

The results are shown in Table~\ref{tbl:survey-small-results-app} for the application code snippets, and
Table~\ref{tbl:survey-small-results-std} for the standard library snippets.
The different classes and an example for each of them is shown in Section~\ref{sec:survey-small-classes}.

%% created by Pandas in notebook table-formatting.ipynb
\begin{table}[h]
    \centering
    \caption{Small-scale study results for application code samples}
    \label{tbl:survey-small-results-app}
    \begin{tabularx}{\textwidth}{Xrrrrrr}
        \toprule
                                          & generics & efficiency & cleaner-code & serialization & inevitable &  unclassified \\
        \midrule
              conversion-struct-byteslice &        1 &            &            1 &               &            &            93 \\
        \rowcolor{verylightgray}
                 conversion-struct-struct &        2 &          2 &            1 &             1 &            &           462 \\
                  conversion-struct-basic &          &          2 &              &               &            &           120 \\
        \rowcolor{verylightgray}
         pointer-arithmetic-memory-layout &        1 &            &            1 &               &            &            15 \\
                     direct-memory-access &          &            &              &               &          1 &            40 \\
        \rowcolor{verylightgray}
                                 delegate &          &            &              &             1 &            &            86 \\
                        conversion-header &          &            &              &               &          1 &            35 \\
        \rowcolor{verylightgray}
                                   unused &          &            &              &               &            &            15 \\
                          type-reflection &          &            &              &               &            &            37 \\
        \rowcolor{verylightgray}
                                  syscall &          &            &              &               &            &            21 \\
                           data-structure &          &            &              &               &            &            36 \\
        \rowcolor{verylightgray}
                                  comment &          &            &              &               &            &            24 \\
                   escape-analysis-escape &          &            &              &               &            &             1 \\
        \bottomrule
    \end{tabularx}
\end{table}

%% created by Pandas in notebook table-formatting.ipynb
\begin{table}[h]
    \centering
    \caption{Small-scale study results for standard library samples}
    \label{tbl:survey-small-results-std}
    \begin{tabularx}{\textwidth}{Xrrr}
        \toprule
                                          & test & not-finished &  unclassified \\
        \midrule
                                  syscall &    3 &              &           151 \\
        \rowcolor{verylightgray}
                     direct-memory-access &      &            2 &            42 \\
         pointer-arithmetic-memory-layout &    2 &              &            25 \\
        \rowcolor{verylightgray}
                          type-reflection &    1 &              &             3 \\
                 conversion-struct-struct &    1 &              &            40 \\
        \rowcolor{verylightgray}
                           data-structure &      &            1 &            21 \\
                  conversion-struct-basic &      &              &             9 \\
        \rowcolor{verylightgray}
                                   unused &      &              &             8 \\
              conversion-struct-byteslice &      &              &            12 \\
        \rowcolor{verylightgray}
                        conversion-header &      &              &             3 \\
                                 delegate &      &              &            68 \\
        \rowcolor{verylightgray}
                   escape-analysis-escape &      &              &             7 \\
                                  comment &      &              &             1 \\
        \bottomrule
    \end{tabularx}
\end{table}

I put each sample along with its classification and information about where it was taken from into its own file.
The files are put into directories whose names indicate both classification dimensions.


%% -----------------------------------------------------------------------------

\section{Classes and examples}\label{sec:survey-small-classes}

Here are examples and descriptions for each of the classes used to describe what is happening in an unsafe usage.

\textbf{conversion-struct-byteslice}

Unsafe pointers are used to cast some struct value into a \texttt{[]byte} value.
Although this is a special case of the next cast, I used it to cover very common serialization operations.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-conversion-struct-byteslice, caption=Usage class example: conversion-struct-byteslice]
func socketControlMessageHeaderAndData(b []byte) (*Cmsghdr, []byte, error) {
    h := (*Cmsghdr)(unsafe.Pointer(&b[0]))
    if h.Len < SizeofCmsghdr || uint64(h.Len) > uint64(len(b)) {
        return nil, nil, EINVAL
    }
    return h, b[cmsgAlignOf(SizeofCmsghdr):h.Len], nil
}
\end{lstlisting}


\textbf{conversion-struct-struct}

Unsafe pointers are used to cast some struct directly into some other struct.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-conversion-struct-struct, caption=Usage class example: conversion-struct-struct]
out.Series = (*core.EventSeries)(unsafe.Pointer(in.Series))
\end{lstlisting}


\textbf{conversion-struct-basic}

Unsafe pointers are used to cast some struct into a basic Go type like \texttt{int32} or \texttt{string}.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-conversion-struct-basic, caption=Usage class example: conversion-struct-basic]
func (codec *float32Codec) IsEmpty(ptr unsafe.Pointer) bool {
    return *((*float32)(ptr)) == 0
}
\end{lstlisting}


\textbf{conversion-header}

Unsafe pointers are used in conjunction with the slice and string headers of the reflect package to cast or construct
slices directly.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-conversion-header, caption=Usage class example: conversion-header]
hdr := &reflect.SliceHeader{
    Data: uintptr(unsafe.Pointer(&data[start])),
    Len:  cols,
    Cap:  cols,
}
retVal[i][j] = *(*[]int16)(unsafe.Pointer(hdr))
\end{lstlisting}


\textbf{delegate}

Unsafe pointers are used only to be passed along to some function that required unsafe pointers in the first place.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-delegate, caption=Usage class example: delegate]
func (type2 *UnsafeMapType) UnsafeSetIndex(obj unsafe.Pointer, key unsafe.Pointer, elem unsafe.Pointer) {
    mapassign(type2.rtype, *(*unsafe.Pointer)(obj), key, elem)
}
\end{lstlisting}


\textbf{unused}

Though there is a variable or parameter of type unsafe pointer, it is not actually used.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-unused, caption=Usage class example: unused]
func (type2 *safeMapType) UnsafeGetIndex(obj unsafe.Pointer, key unsafe.Pointer) unsafe.Pointer {
    panic("does not support unsafe operation")
}
\end{lstlisting}


\textbf{comment}

A comment talks about unsafe pointers, or the code is simply commented.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-comment, caption=Usage class example: comment]
// 	urv := (*unsafeReflectValue)(unsafe.Pointer(&rv))
\end{lstlisting}


\textbf{syscall}

Unsafe pointers are used as arguments in a direct syscall.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-syscall, caption=Usage class example: syscall]
ifreq.Data = uintptr(unsafe.Pointer(&buffer[0]))
_, _, errno = syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), SIOCETHTOOL, uintptr(unsafe.Pointer(ifreq)))
if errno != 0 {
    return -1, fmt.Errorf("SIOCETHTOOL request for %q failed, errno=%v", link.Attrs().Name, errno)
}
\end{lstlisting}


\textbf{data-structure}

A data structure containing unsafe pointers or function declaration is done.
This is possible for example to recreate the slice header structures of the reflect package.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-data-structure, caption=Usage class example: data-structure]
type itab struct {
    ignore unsafe.Pointer
    rtype  unsafe.Pointer
}
\end{lstlisting}


\textbf{pointer-arithmetic-memory-layout}

Using unsafe pointers, there is some form of pointer arithmetic or direct field access in a struct.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-pointer-arithmetic-memory-layout, caption=Usage class example: pointer-arithmetic-memory-layout]
func (p *page) branchPageElement(index uint16) *branchPageElement {
    off := uintptr(index) * unsafe.Sizeof(branchPageElement{})
    return (*branchPageElement)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + unsafe.Sizeof(*p) + off))
}
\end{lstlisting}


\textbf{direct-memory-access}

Unsafe pointers are used or returned to directly dereference into memory.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-direct-memory-access, caption=Usage class example: direct-memory-access]
func (n *decNaked) rl() (v reflect.Value) {
    v = defUnsafeDecNakedWrapper.rl
    ((*unsafeReflectValue)(unsafe.Pointer(&v))).ptr = unsafe.Pointer(&n.l)
    return
}
\end{lstlisting}


\textbf{escape-analysis-escape}

Unsafe pointers are used to deliberately create a value that is hidden to Go escape analysis.
Although the value might and probably will escape, the escape analysis can not realize.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-escape-analysis-escape, caption=Usage class example: escape-analysis-escape]
//go:nosplit
func NoEscape(p unsafe.Pointer) unsafe.Pointer {
    x := uintptr(p)
    return unsafe.Pointer(x ^ 0)
}
\end{lstlisting}


\textbf{type-reflection}

Unsafe pointers are used for some form of type distinction and similar actions for each type.

\begin{lstlisting}[language=Golang, label=lst:survey-small-classexample-type-reflection, caption=Usage class example: type-reflection]
case *string:
    return unsafe.Pointer(ptr), newUnfolderString()
case *[]string:
    return unsafe.Pointer(ptr), newUnfolderArrString()
case *map[string]string:
    return unsafe.Pointer(ptr), newUnfolderMapString()
\end{lstlisting}
