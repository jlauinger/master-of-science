\section{Go's \unsafe{}~package}
\label{sec:background}



The Go programming language, like other memory-safe languages, provides the \unsafe{}~package\footnote{\url{https://golang.org/pkg/unsafe}}, which offers 
(a) the functions \textit{Sizeof}, \textit{Alignof}, and \textit{Offsetof} that are evaluated at compile time and provide access into memory alignment details of Go data types that are otherwise inaccessible, %unnecessary to know, and thus, inaccessible.
and (b) a pointer type, \textit{unsafe.Pointer} that allows developers to circumvent restrictions of regular pointer types.

One can cast any pointer to/from \textit{unsafe.Pointer}, thus enabling casts between completely arbitrary types, as illustrated in  
%
%In the remainders of this section, we discuss two example use cases of the \unsafe{} package in practice. 
Listing~\ref{lst:unsafe-ex-in-place-cast}.
%shows the usage of the \unsafe{} package to cast between arbitrary types.
In this example, \textit{in.Items} is assigned to a new type (\textit{out.Items}) in line 3 without reallocation for efficiency reasons.\footnote{This code was taken from the Kubernetes \textit{k8s.io/apiserver} module with minor adjustments.} 
Furthermore, casts between \textit{unsafe.Pointer} and \textit{uintptr} are also enabled, mainly for pointer arithmetic.
A \textit{uintptr} is an integer type with a length sufficient to store memory addresses. 
However, it is not a pointer type, hence, not treated as a reference.
%The first \textit{unsafe.Pointer} rule allows casts between completely arbitrary types, and the latter one allows the use of pointer arithmetic.
%The usage of the \unsafe{}~package removes the safety net provided by the Go type system and compiler, and brings developers down to the flexibility and danger of the pointers in C.
%
Listing~\ref{lst:unsafe-ex-escape-analysis} presents an example of casts involving \textit{uintptr}. 
%The code is taken from the \textit{modern-go/reflect2} module.
In Line 2, the \textit{unsafe.Pointer} is converted to \textit{uintptr}.
Thus, the memory address is stored within a non-reference type.
Hence, the back-conversion in Line 3 causes the \textit{unsafe.Pointer} to be hidden for the \textit{escape analysis (EA)} that Go's garbage collector uses 
%manages the memory allocations and tries to identify memory which can be freed up.
%For this task, it uses \textit{escape analysis (EA)} 
to determine whether a pointer is local to a function and can be stored in the corresponding stack frame, 
or whether it can \textit{escape} the function and needs to be stored on the heap \cite{wang2020}. 
Since \textit{uintptr} values are not pointer types, storing the address of a pointer in a variable of such a type and then converting it back causes the \textit{EA} to miss the chain of references to the underlying value in memory. 
Therefore, Go will assume a value does not escape when it actually does, and may place it on the stack.
Correctly used it can improve efficiency because deallocation is faster on the stack than on the heap~\cite{wang2020}.
However, used incorrectly it can cause security problems as shown later in Section~\ref{sec:appr}.

\begin{lstlisting}[language=Golang, label=lst:unsafe-ex-in-place-cast, caption=In-place cast using the \unsafe{} package
from the Kubernetes \textit{k8s.io/apiserver} module with minor changes.
,float, belowskip=-1.5em]
func autoConvert(in *PolicyList, out *audit.PolicyList) error {
	// [...]
	out.Items = *(*[]audit.Policy)(unsafe.Pointer(&in.Items))
	return nil
}
\end{lstlisting}

\begin{lstlisting}[language=Golang, label=lst:unsafe-ex-escape-analysis, caption=Hiding a value from escape analysis from the \textit{modern-go/reflect2} module.
, float, belowskip=-1.5em]
func NoEscape(p unsafe.Pointer) unsafe.Pointer {
	x := uintptr(p)
	return unsafe.Pointer(x ^ 0)
}
\end{lstlisting}


% \subsection{Go Dependency Management}

%Old way: packages, Go Path

%New way: modules, registries, \textit{go.mod} file.

%Package cache, versions, bad reproducibility, relatively high error rates for dependency resolution.
